"""This type stub file was generated by pyright."""

import abc
import os
from pathlib import Path
from typing import Dict, List, Mapping, Optional, Sequence, Tuple, Union

"""Build HDL and run cocotb tests."""
PathLike = Union["os.PathLike[str]", str]
Command = List[str]
Timescale = Tuple[str, str]
_magic_re = ...
_space_re = ...

def as_tcl_value(value: str) -> str: ...
def shlex_join(split_command):  # -> str:
    """Return a shell-escaped string from *split_command*
    This is here more for compatibility purposes
    """
    ...

class VHDL(str):
    """Tags source files and build arguments to :meth:`~cocotb.runner.Simulator.build` as VHDL-specific."""

    ...

class Verilog(str):
    """Tags source files and build arguments to :meth:`~cocotb.runner.Simulator.build` as Verilog-specific."""

    ...

class Simulator(abc.ABC):
    supported_gpi_interfaces: Dict[str, List[str]] = ...
    def __init__(self) -> None: ...
    def build(
        self,
        hdl_library: str = ...,
        verilog_sources: Sequence[PathLike] = ...,
        vhdl_sources: Sequence[PathLike] = ...,
        sources: Sequence[Union[PathLike, VHDL, Verilog]] = ...,
        includes: Sequence[PathLike] = ...,
        defines: Mapping[str, object] = ...,
        parameters: Mapping[str, object] = ...,
        build_args: Sequence[Union[str, VHDL, Verilog]] = ...,
        hdl_toplevel: Optional[str] = ...,
        always: bool = ...,
        build_dir: PathLike = ...,
        clean: bool = ...,
        verbose: bool = ...,
        timescale: Optional[Timescale] = ...,
        waves: Optional[bool] = ...,
        log_file: Optional[PathLike] = ...,
    ) -> None:
        """Build the HDL sources.

        With mixed language simulators, *sources* will be built,
        followed by *vhdl_sources*, then *verilog_sources*.
        With simulators that only support either VHDL or Verilog, *sources* will be built,
        followed by *vhdl_sources* and *verilog_sources*, respectively.

        If your source files use an atypical file extension,
        use :class:`VHDL` and :class:`Verilog` to tag the path as a VHDL or Verilog source file, respectively.
        If the filepaths aren't tagged, the extension is used to determine if they are VHDL or Verilog files.

        +----------+------------------------------------+
        | Language | File Extensions                    |
        +==========+====================================+
        | VHDL     | ``.vhd``, ``.vhdl``                |
        +----------+------------------------------------+
        | Verilog  | ``.v``, ``.sv``, ``.vh``, ``.svh`` |
        +----------+------------------------------------+


        .. code-block:: python3

            runner.build(
                sources=[
                    VHDL("/my/file.is_actually_vhdl"),
                    Verilog("/other/file.verilog"),
                ],
            )

        The same tagging works for *build_args*.
        Tagged *build_args* only supply that option to the compiler when building the source file for the tagged language.
        Non-tagged *build_args* are supplied when compiling any language.

        Args:
            hdl_library: The library name to compile into.
            verilog_sources: Verilog source files to build.
            vhdl_sources: VHDL source files to build.
            sources: Language-agnostic list of source files to build.
            includes: Verilog include directories.
            defines: Defines to set.
            parameters: Verilog parameters or VHDL generics.
            build_args: Extra build arguments for the simulator.
            hdl_toplevel: The name of the HDL toplevel module.
            always: Always run the build step.
            build_dir: Directory to run the build step in.
            clean: Delete build_dir before building
            verbose: Enable verbose messages.
            timescale: Tuple containing time unit and time precision for simulation.
            waves: Record signal traces.
            log_file: File to write the build log to.
        """
        ...

    def test(
        self,
        test_module: Union[str, Sequence[str]],
        hdl_toplevel: str,
        hdl_toplevel_library: str = ...,
        hdl_toplevel_lang: Optional[str] = ...,
        gpi_interfaces: Optional[List[str]] = ...,
        testcase: Optional[Union[str, Sequence[str]]] = ...,
        seed: Optional[Union[str, int]] = ...,
        test_args: Sequence[str] = ...,
        plusargs: Sequence[str] = ...,
        extra_env: Mapping[str, str] = ...,
        waves: Optional[bool] = ...,
        gui: Optional[bool] = ...,
        parameters: Mapping[str, object] = ...,
        build_dir: Optional[PathLike] = ...,
        test_dir: Optional[PathLike] = ...,
        results_xml: Optional[str] = ...,
        pre_cmd: List[str] = ...,
        verbose: bool = ...,
        timescale: Optional[Timescale] = ...,
        log_file: Optional[PathLike] = ...,
    ) -> Path:
        """Run the tests.

        Args:
            test_module: Name(s) of the Python module(s) containing the tests to run.
                Can be a comma-separated list.
            hdl_toplevel: Name of the HDL toplevel module.
            hdl_toplevel_library: The library name for HDL toplevel module.
            hdl_toplevel_lang: Language of the HDL toplevel module.
            gpi_interfaces: List of GPI interfaces to use, with the first one being the entry point.
            testcase: Name(s) of a specific testcase(s) to run.
                If not set, run all testcases found in *test_module*.
                Can be a comma-separated list.
            seed: A specific random seed to use.
            test_args: Extra arguments for the simulator.
            plusargs: 'plusargs' to set for the simulator.
            extra_env: Extra environment variables to set.
            waves: Record signal traces.
            gui: Run with simulator GUI.
            parameters: Verilog parameters or VHDL generics.
            build_dir: Directory the build step has been run in.
            test_dir: Directory to run the tests in.
            results_xml: Name of xUnit XML file to store test results in.
                If an absolute path is provided it will be used as-is,
                ``{build_dir}/results.xml`` otherwise.
                This argument should not be set when run with ``pytest``.
            verbose: Enable verbose messages.
            pre_cmd: Commands to run before simulation begins.
            timescale: Tuple containing time unit and time precision for simulation.
            log_file: File to write the test log to.

        Returns:
            The absolute location of the results XML file which can be
            defined by the *results_xml* argument.
        """
        ...

    def rm_build_folder(self, build_dir: Path):  # -> None:
        ...

def get_results(results_xml_file: Path) -> Tuple[int, int]:
    """Return number of tests and fails in *results_xml_file*.

    Returns:
        Tuple of number of tests and number of fails.

    Raises:
        SystemExit: *results_xml_file* is non-existent.
    """
    ...

def check_results_file(results_xml_file: Path) -> None:
    """Raise exception if *results_xml_file* does not exist or contains failed tests.

    Raises:
        SystemExit: *results_xml_file* is non-existent or contains fails.
    """
    ...

def outdated(output: Path, dependencies: Sequence[Path]) -> bool:
    """Return ``True`` if any source files in *dependencies* are newer than the *output* directory.

    Returns:
        ``True`` if any source files are newer, ``False`` otherwise.
    """
    ...

def get_abs_path(path: PathLike) -> Path:
    """Return *path* in absolute form."""
    ...

def get_abs_paths(paths: Sequence[PathLike]) -> List[Path]:
    """Return list of *paths* in absolute form."""
    ...

_verilog_extensions = ...
_vhdl_extensions = ...
_vhdl_extensions_s = ...
_verilog_extensions_s = ...

class UnknownFileExtension(ValueError):
    def __init__(self, source: PathLike) -> None: ...

def is_vhdl_source(source: PathLike) -> bool: ...
def is_verilog_source(source: PathLike) -> bool: ...

class Icarus(Simulator):
    supported_gpi_interfaces = ...
    @property
    def sim_file(self) -> Path: ...
    @property
    def iverilog_dump_file(self) -> Path: ...
    @property
    def cmds_file(self) -> Path: ...

class Questa(Simulator):
    supported_gpi_interfaces = ...

class Ghdl(Simulator):
    supported_gpi_interfaces = ...

class Nvc(Simulator):
    supported_gpi_interfaces = ...

class Riviera(Simulator):
    supported_gpi_interfaces = ...

class Verilator(Simulator):
    supported_gpi_interfaces = ...

class Xcelium(Simulator):
    supported_gpi_interfaces = ...

def get_runner(simulator_name: str) -> Simulator:
    """Return the *simulator_name* instance."""
    ...
