"""This type stub file was generated by pyright."""

import os
from typing import Iterable, Optional, Type

import coverage
from cocotb._deprecation import deprecated
from cocotb.decorators import test as Test
from cocotb.handle import SimHandle
from cocotb.task import Task

"""All things relating to regression capabilities."""
_pdb_on_exception = ...
coverage = ...
if "COVERAGE" in os.environ: ...
_logger = ...
_Failed: Type[BaseException]

class RegressionManager:
    """Encapsulates all regression capability into a single place"""
    def __init__(self, dut: SimHandle, tests: Iterable[Test]) -> None:
        """Args:
        dut (SimHandle): The root handle to pass into test functions.
        tests (Iterable[Test]): tests to run
        """
        ...

    @classmethod
    def from_discovery(cls, dut: SimHandle):  # -> Self:
        """Obtains the test list by discovery.

        See :envvar:`MODULE` and :envvar:`TESTCASE` for details on how tests are discovered.

        Args:
            dut (SimHandle): The root handle to pass into test functions.
        """
        ...

    @deprecated("This method is now private.")
    def tear_down(self) -> None: ...
    @deprecated("This method is now private.")
    def next_test(self) -> Optional[Test]: ...
    @deprecated("This method is now private.")
    def handle_result(self, test: Task) -> None: ...
    @deprecated("This method is now private.")
    def execute(self) -> None: ...

class TestFactory:
    """Factory to automatically generate tests.

    Args:
        test_function: A Callable that returns the test Coroutine.
            Must take *dut* as the first argument.
        *args: Remaining arguments are passed directly to the test function.
            Note that these arguments are not varied. An argument that
            varies with each test must be a keyword argument to the
            test function.
        **kwargs: Remaining keyword arguments are passed directly to the test function.
            Note that these arguments are not varied. An argument that
            varies with each test must be a keyword argument to the
            test function.

    Assuming we have a common test function that will run a test. This test
    function will take keyword arguments (for example generators for each of
    the input interfaces) and generate tests that call the supplied function.

    This Factory allows us to generate sets of tests based on the different
    permutations of the possible arguments to the test function.

    For example, if we have a module that takes backpressure, has two configurable
    features where enabling ``feature_b`` requires ``feature_a`` to be active, and
    need to test against data generation routines ``gen_a`` and ``gen_b``:

    >>> tf = TestFactory(test_function=run_test)
    >>> tf.add_option(name="data_in", optionlist=[gen_a, gen_b])
    >>> tf.add_option("backpressure", [None, random_backpressure])
    >>> tf.add_option(
    ...     ("feature_a", "feature_b"),
    ...     [(False, False), (True, False), (True, True)],
    ... )
    >>> tf.generate_tests()

    We would get the following tests:

        * ``gen_a`` with no backpressure and both features disabled
        * ``gen_a`` with no backpressure and only ``feature_a`` enabled
        * ``gen_a`` with no backpressure and both features enabled
        * ``gen_a`` with ``random_backpressure`` and both features disabled
        * ``gen_a`` with ``random_backpressure`` and only ``feature_a`` enabled
        * ``gen_a`` with ``random_backpressure`` and both features enabled
        * ``gen_b`` with no backpressure and both features disabled
        * ``gen_b`` with no backpressure and only ``feature_a`` enabled
        * ``gen_b`` with no backpressure and both features enabled
        * ``gen_b`` with ``random_backpressure`` and both features disabled
        * ``gen_b`` with ``random_backpressure`` and only ``feature_a`` enabled
        * ``gen_b`` with ``random_backpressure`` and both features enabled

    The tests are appended to the calling module for auto-discovery.

    Tests are simply named ``test_function_N``. The docstring for the test (hence
    the test description) includes the name and description of each generator.

    .. versionchanged:: 1.5
        Groups of options are now supported
    """

    __test__ = ...
    def __init__(self, test_function, *args, **kwargs) -> None: ...
    def add_option(self, name, optionlist):  # -> None:
        """Add a named option to the test.

        Args:
            name (str or iterable of str): An option name, or an iterable of
                several option names.  Passed to test as keyword arguments.

            optionlist (list): A list of possible options for this test knob.
                If N names were specified, this must be a list of N-tuples or
                lists, where each element specifies a value for its respective
                option.

        .. versionchanged:: 1.5
            Groups of options are now supported
        """
        ...

    def generate_tests(self, prefix=..., postfix=...):  # -> None:
        """Generate an exhaustive set of tests using the cartesian product of the
        possible keyword arguments.

        The generated tests are appended to the namespace of the calling
        module.

        Args:
            prefix (str):  Text string to append to start of ``test_function`` name
                     when naming generated test cases. This allows reuse of
                     a single ``test_function`` with multiple
                     :class:`TestFactories <.TestFactory>` without name clashes.
            postfix (str): Text string to append to end of ``test_function`` name
                     when naming generated test cases. This allows reuse of
                     a single ``test_function`` with multiple
                     :class:`TestFactories <.TestFactory>` without name clashes.
        """
        ...
