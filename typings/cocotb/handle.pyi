"""This type stub file was generated by pyright."""

import enum

from cocotb.binary import BinaryValue

_deprecation_warned = ...

class _Limits(enum.IntEnum):
    SIGNED_NBIT = ...
    UNSIGNED_NBIT = ...
    VECTOR_NBIT = ...

class SimHandleBase:
    """Base class for all simulation objects.

    We maintain a handle which we can use for GPI calls.
    """

    _compat_mapping = ...
    def __init__(self, handle, path) -> None:
        """.. Constructor. This RST comment works around sphinx-doc/sphinx#6885

        Args:
            handle (int): The GPI handle to the simulator object.
            path (str): Path to this handle, ``None`` if root.
        """
        ...

    def get_definition_name(self):  # -> str:
        ...
    def get_definition_file(self):  # -> str:
        ...
    def __hash__(self) -> int: ...
    def __len__(self):  # -> int | None:
        """Return the "length" (the number of elements) of the underlying object.

        For vectors this is the number of bits.
        """
        ...

    def __eq__(self, other) -> bool:
        """Compare equality of handles.

        Example usage::

            if clk == dut.clk:
                do_something()
        """
        ...

    def __ne__(self, other) -> bool: ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...
    def __setattr__(self, name, value):  # -> None:
        ...
    def __getattr__(self, name):  # -> Any:
        ...

class RegionObject(SimHandleBase):
    """A region object, such as a scope or namespace.

    Region objects don't have values, they are effectively scopes or namespaces.
    """
    def __init__(self, handle, path) -> None: ...
    def __iter__(self):  # -> Generator[Any, Any, None]:
        """Iterate over all known objects in this layer of hierarchy."""
        ...

    def __dir__(self):
        """Permits IPython tab completion to work."""
        ...

class HierarchyObject(RegionObject):
    """Hierarchy objects are namespace/scope objects."""
    def __setattr__(self, name, value):  # -> None:
        """Provide transparent access to signals via the hierarchy.

        Slightly hacky version of operator overloading in Python.

        Raise an :exc:`AttributeError` if users attempt to create new members which
        don't exist in the design.
        """
        ...

    def __getattr__(
        self, name
    ):  # -> Any | ConstantObject | EnumObject | HierarchyArrayObject | HierarchyObject | IntegerObject | ModifiableObject | RealObject | StringObject | NonHierarchyIndexableObject:
        """Query the simulator for an object with the specified name
        and cache the result to build a tree of objects.
        """
        ...

class HierarchyArrayObject(RegionObject):
    """Hierarchy Arrays are containers of Hierarchy Objects."""
    def __len__(self):  # -> int:
        """Return the "length" of the generate block."""
        ...

    def __getitem__(self, index): ...
    def __setitem__(self, index, value): ...

class _AssignmentResult:
    """An object that exists solely to provide an error message if the caller
    is not aware of cocotb's meaning of ``<=``.
    """
    def __init__(self, signal, value) -> None: ...
    def __bool__(self): ...

class NonHierarchyObject(SimHandleBase):
    """Common base class for all non-hierarchy objects."""
    def __iter__(self):  # -> Iterator[Never]:
        ...
    @property
    def value(self):
        """The value of this simulation object.

        .. note::
            When setting this property, the value is stored by the :class:`~cocotb.scheduler.Scheduler`
            and all stored values are written at the same time at the end of the current simulator time step.

            Use :meth:`setimmediatevalue` to set the value immediately.
        """
        ...

    @value.setter
    def value(self, value): ...
    def setimmediatevalue(self, value):
        """Assign a value to this simulation object immediately."""
        ...

    def __le__(self, value) -> bool:
        """Overload less-than-or-equal-to operator to provide an HDL-like shortcut.

        Example:
        >>> module.signal <= 2
        """
        ...

    def __eq__(self, other) -> bool:
        """Equality comparator for non-hierarchy objects

        If ``other`` is not a :class:`SimHandleBase` instance the comparison
        uses the comparison method of the ``other`` object against our
        ``.value``.
        """
        ...

    def __ne__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class ConstantObject(NonHierarchyObject):
    """An object which has a value that can be read, but not set.

    The value is cached in the class since it is fixed at elaboration
    time and won't change within a simulation.
    """
    def __init__(self, handle, path, handle_type) -> None:
        """Args:
        handle (int): The GPI handle to the simulator object.
        path (str): Path to this handle, ``None`` if root.
        handle_type: The type of the handle
            (``simulator.INTEGER``, ``simulator.ENUM``,
            ``simulator.REAL``, ``simulator.STRING``).
        """
        ...

    def __int__(self) -> int: ...
    def __float__(self):  # -> float:
        ...
    @NonHierarchyObject.value.getter
    def value(self):  # -> BinaryValue:
        """The value of this simulation object."""
        ...

    def __str__(self) -> str: ...

class NonHierarchyIndexableObject(NonHierarchyObject):
    """A non-hierarchy indexable object.

    Getting and setting the current value of an array is done
    by iterating through sub-handles in left-to-right order.

    Given an HDL array ``arr``:

    +--------------+---------------------+--------------------------------------------------------------+
    | Verilog      | VHDL                | ``arr.value`` is equivalent to                               |
    +==============+=====================+==============================================================+
    | ``arr[4:7]`` | ``arr(4 to 7)``     | ``[arr[4].value, arr[5].value, arr[6].value, arr[7].value]`` |
    +--------------+---------------------+--------------------------------------------------------------+
    | ``arr[7:4]`` | ``arr(7 downto 4)`` | ``[arr[7].value, arr[6].value, arr[5].value, arr[4].value]`` |
    +--------------+---------------------+--------------------------------------------------------------+

    When setting the signal as in ``arr.value = ...``, the same index equivalence as noted in the table holds.

    .. warning::
        Assigning a value to a sub-handle:

        - **Wrong**: ``dut.some_array.value[0] = 1`` (gets value as a list then updates index 0)
        - **Correct**: ``dut.some_array[0].value = 1``
    """
    def __init__(self, handle, path) -> None: ...
    def __setitem__(self, index, value):  # -> None:
        """Provide transparent assignment to indexed array handles."""
        ...

    def __getitem__(self, index): ...
    def __iter__(self):  # -> Generator[Any, Any, None]:
        ...
    @NonHierarchyObject.value.getter
    def value(self) -> list: ...

class NonConstantObject(NonHierarchyIndexableObject):
    """A non-constant object"""
    def drivers(self):
        """An iterator for gathering all drivers for a signal.

        This is currently only available for VPI.
        Also, only a few simulators implement this.
        """
        ...

    def loads(self):
        """An iterator for gathering all loads on a signal.

        This is currently only available for VPI.
        Also, only a few simulators implement this.
        """
        ...

class _SetAction:
    """Base class representing the type of action used while write-accessing a handle."""

    ...

class _SetValueAction(_SetAction):
    __slots__ = ...
    def __init__(self, value) -> None: ...

class Deposit(_SetValueAction):
    """Action used for placing a value into a given handle."""

    ...

class Force(_SetValueAction):
    """Action used to force a handle to a given value until a release is applied."""

    ...

class Freeze(_SetAction):
    """Action used to make a handle keep its current value until a release is used."""

    ...

class Release(_SetAction):
    """Action used to stop the effects of a previously applied force/freeze action."""

    ...

class ModifiableObject(NonConstantObject):
    """Base class for simulator objects whose values can be modified."""
    @NonConstantObject.value.getter
    def value(self) -> BinaryValue: ...
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...

class RealObject(ModifiableObject):
    """Specific object handle for Real signals and variables."""
    @ModifiableObject.value.getter
    def value(self) -> float: ...
    def __float__(self):  # -> float:
        ...

class EnumObject(ModifiableObject):
    """Specific object handle for enumeration signals and variables."""
    @ModifiableObject.value.getter
    def value(self) -> int: ...

class IntegerObject(ModifiableObject):
    """Specific object handle for integer and enumeration signals and variables."""
    @ModifiableObject.value.getter
    def value(self) -> int: ...

class StringObject(ModifiableObject):
    """Specific object handle for String variables."""
    @ModifiableObject.value.getter
    def value(self) -> bytes: ...
    def __str__(self) -> str: ...

_handle2obj = ...

def SimHandle(
    handle, path=...
):  # -> ConstantObject | EnumObject | HierarchyArrayObject | HierarchyObject | IntegerObject | ModifiableObject | RealObject | StringObject | NonHierarchyIndexableObject:
    """Factory function to create the correct type of `SimHandle` object.

    Args:
        handle (int): The GPI handle to the simulator object.
        path (str): Path to this handle, ``None`` if root.

    Returns:
        The `SimHandle` object.

    Raises:
        NotImplementedError: If no matching object for GPI type could be found.
    """
    ...
