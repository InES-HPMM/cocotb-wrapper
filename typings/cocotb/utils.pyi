"""This type stub file was generated by pyright."""

from decimal import Decimal
from numbers import Real
from typing import Union

"""Collection of handy functions."""

def get_python_integer_types():  # -> tuple[type[int]]:
    ...
def get_sim_time(units: str = ...) -> int:
    """Retrieves the simulation time from the simulator.

    Args:
        units: String specifying the units of the result
            (one of ``'step'``, ``'fs'``, ``'ps'``, ``'ns'``, ``'us'``, ``'ms'``, ``'sec'``).
            ``'step'`` will return the raw simulation time.

            .. deprecated:: 1.6.0
                Using ``None`` as the *units* argument is deprecated, use ``'step'`` instead.

    Returns:
        The simulation time in the specified units.

    .. versionchanged:: 1.6.0
        Support ``'step'`` as the the *units* argument to mean "simulator time step".
    """
    ...

def get_time_from_sim_steps(steps: int, units: str) -> int:
    """Calculates simulation time in the specified *units* from the *steps* based
    on the simulator precision.

    Args:
        steps: Number of simulation steps.
        units: String specifying the units of the result
            (one of ``'fs'``, ``'ps'``, ``'ns'``, ``'us'``, ``'ms'``, ``'sec'``).

    Returns:
        The simulation time in the specified units.
    """
    ...

def get_sim_steps(
    time: Union[Real, Decimal], units: str = ..., *, round_mode: str = ...
) -> int:
    """Calculates the number of simulation time steps for a given amount of *time*.

    When *round_mode* is ``"error"``, a :exc:`ValueError` is thrown if the value cannot
    be accurately represented in terms of simulator time steps.
    When *round_mode* is ``"round"``, ``"ceil"``, or ``"floor"``, the corresponding
    rounding function from the standard library will be used to round to a simulator
    time step.

    Args:
        time: The value to convert to simulation time steps.
        units: String specifying the units of the result
            (one of ``'step'``, ``'fs'``, ``'ps'``, ``'ns'``, ``'us'``, ``'ms'``, ``'sec'``).
            ``'step'`` means *time* is already in simulation time steps.
        round_mode: String specifying how to handle time values that sit between time steps
            (one of ``'error'``, ``'round'``, ``'ceil'``, ``'floor'``).

    Returns:
        The number of simulation time steps.

    Raises:
        ValueError: if the value cannot be represented accurately in terms of simulator
            time steps when *round_mode* is ``"error"``.

    .. versionchanged:: 1.5
        Support ``'step'`` as the *units* argument to mean "simulator time step".

    .. versionchanged:: 1.6
        Support rounding modes.
    """
    ...

def pack(ctypes_obj):  # -> bytes:
    """Convert a :mod:`ctypes` structure into a Python string.

    Args:
        ctypes_obj (ctypes.Structure): The :mod:`ctypes` structure to convert to a string.

    Returns:
        New Python string containing the bytes from memory holding *ctypes_obj*.

    .. deprecated:: 1.5
        This function is deprecated, use ``bytes(ctypes_obj)`` instead.
    """
    ...

def unpack(ctypes_obj, string, bytes=...):  # -> None:
    """Unpack a Python string into a :mod:`ctypes` structure.

    If the length of *string* is not the correct size for the memory
    footprint of the :mod:`ctypes` structure then the *bytes* keyword argument
    must be used.

    Args:
        ctypes_obj (ctypes.Structure): The :mod:`ctypes` structure to pack into.
        string (str):  String to copy over the *ctypes_obj* memory space.
        bytes (int, optional): Number of bytes to copy.
            Defaults to ``None``, meaning the length of *string* is used.

    Raises:
        :exc:`ValueError`: If length of *string* and size of *ctypes_obj*
            are not equal.
        :exc:`MemoryError`: If *bytes* is longer than size of *ctypes_obj*.

    .. deprecated:: 1.5
        Converting bytes to a ctypes object should be done with :meth:`~ctypes._CData.from_buffer_copy`.
        If you need to assign bytes into an *existing* ctypes object, use ``memoryview(ctypes_obj).cast('B')[:bytes] = string``,
        see :class:`memoryview` for details.
    """
    ...

def hexdump(x: bytes) -> str:
    """Hexdump a buffer.

    Args:
        x: Object that supports conversion to :class:`bytes`.

    Returns:
        A string containing the hexdump.

    .. deprecated:: 1.4
        Passing a :class:`str` to this function is deprecated, as it
        is not an appropriate type for binary data. Doing so anyway
        will encode the string to ``latin1``.

    .. deprecated:: 1.6.0
        The function will be removed in the next major version.
        Use :func:`scapy.utils.hexdump` instead.

    Example:
        >>> print(hexdump(b"this somewhat long string"))
        0000   74 68 69 73 20 73 6F 6D 65 77 68 61 74 20 6C 6F   this somewhat lo
        0010   6E 67 20 73 74 72 69 6E 67                        ng string
        <BLANKLINE>
    """
    ...

def hexdiffs(x: bytes, y: bytes) -> str:
    r"""Return a diff string showing differences between two binary strings.

    Args:
        x: Object that supports conversion to :class:`bytes`.
        y: Object that supports conversion to :class:`bytes`.

    .. deprecated:: 1.4
        Passing :class:`str`\ s to this function is deprecated, as it
        is not an appropriate type for binary data. Doing so anyway
        will encode the string to ``latin1``.

    .. deprecated:: 1.6.0
        The function will be removed in the next major version.
        Use :func:`scapy.utils.hexdiff` instead.

    Example:
        >>> print(hexdiffs(b"a", b"b"))
        0000      61                                               a
             0000 62                                               b
        <BLANKLINE>
        >>> print(hexdiffs(b"this short thing", b"this also short"))
        0000      746869732073686F 7274207468696E67 this short thing
             0000 7468697320616C73 6F  2073686F7274 this also  short
        <BLANKLINE>
    """
    ...

class ParametrizedSingleton(type):
    """A metaclass that allows class construction to reuse an existing instance.

    We use this so that :class:`RisingEdge(sig) <cocotb.triggers.RisingEdge>` and :class:`Join(coroutine) <cocotb.triggers.Join>` always return
    the same instance, rather than creating new copies.
    """
    def __init__(cls, *args, **kwargs) -> None: ...
    def __singleton_key__(cls, *args, **kwargs):
        """Convert the construction arguments into a normalized representation that
        uniquely identifies this singleton.
        """
        ...

    def __call__(cls, *args, **kwargs):  # -> Any:
        ...
    @property
    def __signature__(cls):  # -> Signature:
        ...

def reject_remaining_kwargs(name, kwargs):  # -> None:
    """Helper function to emulate Python 3 keyword-only arguments.

    Use as::

        def func(x1, **kwargs):
            a = kwargs.pop("a", 1)
            b = kwargs.pop("b", 2)
            reject_remaining_kwargs("func", kwargs)
            ...

    To emulate the Python 3 syntax::

        def func(x1, *, a=1, b=2): ...

    .. deprecated:: 1.4
        Since the minimum supported Python version is now 3.5, this function
        is not needed.
    """
    ...

class lazy_property:
    """A property that is executed the first time, then cached forever.

    It does this by replacing itself on the instance, which works because
    unlike `@property` it does not define __set__.

    This should be used for expensive members of objects that are not always
    used.
    """
    def __init__(self, fget) -> None: ...
    def __get__(self, obj, cls):  # -> Self:
        ...

def want_color_output():  # -> bool | Any:
    """Return ``True`` if colored output is possible/requested and not running in GUI.

    Colored output can be explicitly requested by setting :envvar:`COCOTB_ANSI_OUTPUT` to  ``1``.
    """
    ...

def remove_traceback_frames(
    tb_or_exc, frame_names
):  # -> BaseException | tuple[Any, Any, BaseException | tuple[Any, Any, Any] | Any]:
    """Strip leading frames from a traceback

    Args:
        tb_or_exc (Union[traceback, BaseException, exc_info]):
            Object to strip frames from. If an exception is passed, creates
            a copy of the exception with a new shorter traceback. If a tuple
            from `sys.exc_info` is passed, returns the same tuple with the
            traceback shortened
        frame_names (List[str]):
            Names of the frames to strip, which must be present.
    """
    ...

def walk_coro_stack(coro):  # -> Generator[tuple[Any, Any], Any, None]:
    """Walk down the coroutine stack, starting at *coro*.

    Supports coroutines and generators.
    """
    ...

def extract_coro_stack(coro, limit=...):  # -> StackSummary:
    """Create a list of pre-processed entries from the coroutine stack.

    This is based on :func:`traceback.extract_tb`.

    If *limit* is omitted or ``None``, all entries are extracted.
    The list is a :class:`traceback.StackSummary` object, and
    each entry in the list is a :class:`traceback.FrameSummary` object
    containing attributes ``filename``, ``lineno``, ``name``, and ``line``
    representing the information that is usually printed for a stack
    trace.  The line is a string with leading and trailing
    whitespace stripped; if the source is not available it is ``None``.
    """
    ...
