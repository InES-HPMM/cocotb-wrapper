"""This type stub file was generated by pyright."""

import sys
import typing

from cocotb.utils import lazy_property

def public(f):
    """Use a decorator to avoid retyping function/class names.

    * Based on an idea by Duncan Booth:
    http://groups.google.com/group/comp.lang.python/msg/11cbb03e09611b8a
    * Improved via a suggestion by Dave Angel:
    http://groups.google.com/group/comp.lang.python/msg/3d400fb22d8a42e1
    """
    ...

class coroutine:
    """Decorator class that allows us to provide common coroutine mechanisms:

    ``log`` methods will log to ``cocotb.coroutine.name``.

    :meth:`~cocotb.task.Task.join` method returns an event which will fire when the coroutine exits.

    Used as ``@cocotb.coroutine``.
    """
    def __init__(self, func) -> None: ...
    @lazy_property
    def log(self):  # -> Logger:
        ...
    def __call__(self, *args, **kwargs):  # -> _RunningCoroutine[Any]:
        ...
    def __get__(self, obj, owner=...):  # -> Self:
        """Permit the decorator to be used on class methods
        and standalone functions
        """
        ...

    def __iter__(self):  # -> Self:
        ...
    def __str__(self) -> str: ...

@public
class function:
    """Decorator class that allows a function to block.

    This allows a coroutine that consumes simulation time
    to be called by a thread started with :class:`cocotb.external`;
    in other words, to internally block while externally
    appear to yield.
    """
    def __init__(self, func) -> None: ...
    @lazy_property
    def log(self):  # -> Logger:
        ...
    def __call__(self, *args, **kwargs): ...
    def __get__(self, obj, owner=...):  # -> Self:
        """Permit the decorator to be used on class methods
        and standalone functions
        """
        ...

@public
class external:
    """Decorator to apply to an external function to enable calling from cocotb.

    This turns a normal function that isn't a coroutine into a blocking coroutine.
    Currently, this creates a new execution thread for each function that is
    called.
    Scope for this to be streamlined to a queue in future.
    """
    def __init__(self, func) -> None: ...
    def __call__(self, *args, **kwargs):  # -> CoroutineType[Any, Any, Any]:
        ...
    def __get__(self, obj, owner=...):  # -> Self:
        """Permit the decorator to be used on class methods
        and standalone functions
        """
        ...

class _decorator_helper(type):
    """Metaclass that allows a type to be constructed using decorator syntax,
    passing the decorated function as the first argument. Supports
    construction with or without having the type called.

    So:

        @MyClass(construction, args='go here')
        def this_is_passed_as_f(...):
            pass

    ends up calling

        MyClass.__init__(this_is_passed_as_f, construction, args='go here')
    """
    def __call__(cls, *args, **kwargs):  # -> Any | Callable[..., Any]:
        ...

@public
class test(coroutine, metaclass=_decorator_helper):
    """Decorator to mark a Callable which returns a Coroutine as a test.

    The test decorator provides a test timeout, and allows us to mark tests as skipped
    or expecting errors or failures.
    Tests are evaluated in the order they are defined in a test module.

    Used as ``@cocotb.test(...)``.

    Args:
        timeout_time (numbers.Real or decimal.Decimal, optional):
            Simulation time duration before timeout occurs.

            .. versionadded:: 1.3

            .. note::
                Test timeout is intended for protection against deadlock.
                Users should use :class:`~cocotb.triggers.with_timeout` if they require a
                more general-purpose timeout mechanism.

        timeout_unit (str, optional):
            Units of timeout_time, accepts any units that :class:`~cocotb.triggers.Timer` does.

            .. versionadded:: 1.3

            .. deprecated:: 1.5
                Using ``None`` as the *timeout_unit* argument is deprecated, use ``'step'`` instead.

        expect_fail (bool, optional):
            If ``True`` and the test fails a functional check via an ``assert`` statement, :class:`pytest.raises`,
            :class:`pytest.warns`, or :class:`pytest.deprecated_call` the test is considered to have passed.
            If ``True`` and the test passes successfully, the test is considered to have failed.

        expect_error (exception type or tuple of exception types, optional):
            Mark the result as a pass only if one of the exception types is raised in the test.
            This is primarily for cocotb internal regression use for when a simulator error is expected.

            Users are encouraged to use the following idiom instead::

                @cocotb.test()
                async def my_test(dut):
                    try:
                        await thing_that_should_fail()
                    except ExceptionIExpect:
                        pass
                    else:
                        assert False, "Exception did not occur"

            .. versionchanged:: 1.3
                Specific exception types can be expected

            .. deprecated:: 1.5
                Passing a :class:`bool` value is now deprecated.
                Pass a specific :class:`Exception` or a tuple of Exceptions instead.

        skip (bool, optional):
            Don't execute this test as part of the regression. Test can still be run
            manually by setting :make:var:`TESTCASE`.

        stage (int)
            Order tests logically into stages, where multiple tests can share a stage.
            Defaults to 0.
    """

    _id_count = ...
    def __init__(
        self,
        f,
        timeout_time=...,
        timeout_unit=...,
        expect_fail=...,
        expect_error=...,
        skip=...,
        stage=...,
    ) -> None: ...
    def __call__(self, *args, **kwargs):  # -> _RunningTest[Any]:
        ...

if sys.version_info < (3, 7): ...
else:
    def __getattr__(attr: str) -> typing.Any: ...
