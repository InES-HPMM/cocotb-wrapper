"""This type stub file was generated by pyright."""

import abc
from collections.abc import Awaitable
from decimal import Decimal
from numbers import Real
from typing import Any, Callable, Coroutine, Optional, TypeVar, Union

from cocotb._deprecation import deprecated
from cocotb.task import Task
from cocotb.utils import ParametrizedSingleton, lazy_property

"""A collections of triggers which a testbench can await."""
T = TypeVar("T")

class TriggerException(Exception): ...

class Trigger(Awaitable):
    """Base class to derive from."""

    __slots__ = ...
    def __init__(self) -> None: ...
    @lazy_property
    def log(self):  # -> Logger:
        ...
    @abc.abstractmethod
    def prime(self, callback):  # -> None:
        """Set a callback to be invoked when the trigger fires.

        The callback will be invoked with a single argument, `self`.

        Sub-classes must override this, but should end by calling the base class
        method.

        .. warning::
            Do not call this directly within a :term:`task`. It is intended to be used
            only by the scheduler.
        """
        ...

    def unprime(self):  # -> None:
        """Remove the callback, and perform cleanup if necessary.

        After being un-primed, a Trigger may be re-primed again in the future.
        Calling `unprime` multiple times is allowed, subsequent calls should be
        a no-op.

        Sub-classes may override this, but should end by calling the base class
        method.

        .. warning::
            Do not call this directly within a :term:`task`. It is intended to be used
            only by the scheduler.
        """
        ...

    def __del__(self):  # -> None:
        ...
    def __await__(self):  # -> Generator[Self, Any, Any]:
        ...

class PythonTrigger(Trigger):
    """Python triggers don't use GPI at all.

    For example: notification of coroutine completion.
    """

    ...

class GPITrigger(Trigger):
    """Base Trigger class for GPI triggers.

    Consumes simulation time.
    """

    __slots__ = ...
    def __init__(self) -> None: ...
    def unprime(self):  # -> None:
        """Disable a primed trigger, can be re-primed."""
        ...

class Timer(GPITrigger):
    """Fire after the specified simulation time period has elapsed."""

    round_mode: str = ...
    def __init__(
        self,
        time: Union[Real, Decimal] = ...,
        units: str = ...,
        *,
        round_mode: Optional[str] = ...,
        time_ps: Union[Real, Decimal] = ...,
    ) -> None:
        """Args:
           time: The time value.

               .. versionchanged:: 1.5.0
                  Previously this argument was misleadingly called `time_ps`.

           units: One of
               ``'step'``, ``'fs'``, ``'ps'``, ``'ns'``, ``'us'``, ``'ms'``, ``'sec'``.
               When *units* is ``'step'``,
               the timestep is determined by the simulator (see :make:var:`COCOTB_HDL_TIMEPRECISION`).

            round_mode (str, optional):
                String specifying how to handle time values that sit between time steps
                (one of ``'error'``, ``'round'``, ``'ceil'``, ``'floor'``).

        Examples:
            >>> await Timer(100, units="ps")

            The time can also be a ``float``:

            >>> await Timer(100e-9, units="sec")

            which is particularly convenient when working with frequencies:

            >>> freq = 10e6  # 10 MHz
            >>> await Timer(1 / freq, units="sec")

            Other builtin exact numeric types can be used too:

            >>> from fractions import Fraction
            >>> await Timer(Fraction(1, 10), units="ns")

            >>> from decimal import Decimal
            >>> await Timer(Decimal("100e-9"), units="sec")

            These are most useful when using computed durations while
            avoiding floating point inaccuracies.

        See Also:
            :func:`~cocotb.utils.get_sim_steps`

        Raises:
            TriggerException: If a negative value is passed for Timer setup.

        .. versionchanged:: 1.5
            Raise an exception when Timer uses a negative value as it is undefined behavior.
            Warn for 0 as this will cause erratic behavior in some simulators as well.

        .. versionchanged:: 1.5
            Support ``'step'`` as the *units* argument to mean "simulator time step".

        .. deprecated:: 1.5
            Using ``None`` as the *units* argument is deprecated, use ``'step'`` instead.

        .. versionchanged:: 1.6
            Support rounding modes.
        """
        ...

    def prime(self, callback):  # -> None:
        """Register for a timed callback."""
        ...

    def __repr__(self):  # -> str:
        ...

class _ParameterizedSingletonAndABC(ParametrizedSingleton, abc.ABCMeta): ...

class ReadOnly(GPITrigger, metaclass=_ParameterizedSingletonAndABC):
    """Fires when the current simulation timestep moves to the read-only phase.

    The read-only phase is entered when the current timestep no longer has any further delta steps.
    This will be a point where all the signal values are stable as there are no more RTL events scheduled for the timestep.
    The simulator will not allow scheduling of more events in this timestep.
    Useful for monitors which need to wait for all processes to execute (both RTL and cocotb) to ensure sampled signal values are final.
    """

    __slots__ = ...
    @classmethod
    def __singleton_key__(cls):  # -> None:
        ...
    def __init__(self) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

class ReadWrite(GPITrigger, metaclass=_ParameterizedSingletonAndABC):
    """Fires when the read-write portion of the simulation cycles is reached."""

    __slots__ = ...
    @classmethod
    def __singleton_key__(cls):  # -> None:
        ...
    def __init__(self) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

class NextTimeStep(GPITrigger, metaclass=_ParameterizedSingletonAndABC):
    """Fires when the next time step is started."""

    __slots__ = ...
    @classmethod
    def __singleton_key__(cls):  # -> None:
        ...
    def __init__(self) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

class _EdgeBase(GPITrigger, metaclass=_ParameterizedSingletonAndABC):
    """Internal base class that fires on a given edge of a signal."""

    __slots__ = ...
    @classmethod
    def __singleton_key__(cls, signal): ...
    def __init__(self, signal) -> None: ...
    def prime(self, callback):  # -> None:
        """Register notification of a value change via a callback"""
        ...

    def __repr__(self):  # -> str:
        ...

class RisingEdge(_EdgeBase):
    """Fires on the rising edge of *signal*, on a transition from ``0`` to ``1``."""

    __slots__ = ...
    _edge_type = ...

class FallingEdge(_EdgeBase):
    """Fires on the falling edge of *signal*, on a transition from ``1`` to ``0``."""

    __slots__ = ...
    _edge_type = ...

class Edge(_EdgeBase):
    """Fires on any value change of *signal*."""

    __slots__ = ...
    _edge_type = ...

class _Event(PythonTrigger):
    """Unique instance used by the Event object.

    One created for each attempt to wait on the event so that the scheduler
    can maintain a dictionary of indexing each individual coroutine.

    FIXME: This will leak - need to use peers to ensure everything is removed
    """
    def __init__(self, parent) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def __call__(self):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

class Event:
    """Event to permit synchronization between two coroutines.

    Awaiting :meth:`wait()` from one coroutine will block the coroutine until
    :meth:`set()` is called somewhere else.
    """
    def __init__(self, name=...) -> None: ...
    @property
    @deprecated(
        "The `.fired` attribute is deprecated, use `.is_set()` instead."
    )
    def fired(self) -> bool: ...
    def set(self, data=...):  # -> None:
        """Wake up all coroutines blocked on this event."""
        ...

    def wait(self):  # -> NullTrigger | _Event:
        """Get a trigger which fires when another coroutine sets the event.

        If the event has already been set, the trigger will fire immediately.

        To reset the event (and enable the use of ``wait`` again),
        :meth:`clear` should be called.
        """
        ...

    def clear(self):  # -> None:
        """Clear this event that has fired.

        Subsequent calls to :meth:`~cocotb.triggers.Event.wait` will block until
        :meth:`~cocotb.triggers.Event.set` is called again.
        """
        ...

    def is_set(self) -> bool:
        """Return ``True`` if event has been set."""
        ...

    def __repr__(self):  # -> str:
        ...

class _InternalEvent(PythonTrigger):
    """Event used internally for triggers that need cross-coroutine synchronization.

    This Event can only be waited on once, by a single coroutine.

    Provides transparent __repr__ pass-through to the Trigger using this event,
    providing a better debugging experience.
    """
    def __init__(self, parent) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def set(self, data=...):  # -> None:
        """Wake up coroutine blocked on this event."""
        ...

    def is_set(self) -> bool:
        """Return true if event has been set."""
        ...

    def __await__(self):  # -> Generator[Self, Any, Any]:
        ...
    def __repr__(self):  # -> str:
        ...

class _Lock(PythonTrigger):
    """Unique instance used by the Lock object.

    One created for each attempt to acquire the Lock so that the scheduler
    can maintain a dictionary of indexing each individual coroutine.

    FIXME: This will leak - need to use peers to ensure everything is removed.
    """
    def __init__(self, parent) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def __call__(self):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

_FT = TypeVar("_FT", bound=Callable)

class _LockBackCompat:
    def __init__(self, inst, func) -> None: ...
    def __call__(self): ...
    def __bool__(self): ...

class Lock:
    """Lock primitive (not re-entrant).

    This can be used as::

        await lock.acquire()
        try:
            # do some stuff
        finally:
            lock.release()

    .. versionchanged:: 1.4

        The lock can be used as an asynchronous context manager in an
        :keyword:`async with` statement::

            async with lock:
                # do some stuff
    """
    def __init__(self, name=...) -> None: ...
    @_locked_back_compat_dec
    def locked(self) -> bool:
        """Return ``True`` if the lock has been acquired.

        .. versionchanged:: 2.0
            This is now a method rather than an attribute, to match :meth:`asyncio.Lock.locked`.
        """
        ...

    def acquire(self):  # -> _Lock:
        """Produce a trigger which fires when the lock is acquired."""
        ...

    def release(self):  # -> None:
        """Release the lock."""
        ...

    def __repr__(self):  # -> str:
        ...
    @deprecated(
        "`bool(lock)` is deprecated. Use the `.locked()` method instead."
    )
    def __bool__(self):  # -> bool:
        """Provide boolean of a Lock"""
        ...

    async def __aenter__(self): ...
    async def __aexit__(self, exc_type, exc, tb):  # -> None:
        ...

class NullTrigger(Trigger):
    """Fires immediately.

    Primarily for internal scheduler use.
    """
    def __init__(self, name=..., outcome=..., _outcome=...) -> None: ...
    def prime(self, callback):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

class Join(PythonTrigger, metaclass=_ParameterizedSingletonAndABC):
    r"""Fires when a task completes.

    The result of blocking on the trigger can be used to get the coroutine
    result::

        async def coro_inner():
            await Timer(1, units="ns")
            return "Hello world"

        task = cocotb.start_soon(coro_inner())
        result = await Join(task)
        assert result == "Hello world"

    If the coroutine threw an exception, the :keyword:`await` will re-raise it.

    """

    __slots__ = ...
    @classmethod
    def __singleton_key__(cls, coroutine): ...
    def __init__(self, coroutine) -> None: ...
    @property
    @deprecated("Use `task.result()` to get the result of a joined Task.")
    def retval(self):
        """The return value of the joined coroutine.

        .. deprecated:: 1.9

            Use :meth:`Task.result() <cocotb.task.Task.result` to get the result of a joined Task.

            .. code-block: python3

                forked = cocotb.start_soon(mycoro())
                await forked.join()
                result = forked.result()
        """
        ...

    def prime(self, callback):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...
    def __await__(self):  # -> Generator[Self, Any, Any]:
        ...

class Waitable(Awaitable):
    """Base class for trigger-like objects implemented using coroutines.

    This converts a `_wait` abstract method into a suitable `__await__`.
    """

    __slots__ = ...
    def __await__(self):  # -> Generator[Any, None, Any]:
        ...

class _AggregateWaitable(Waitable):
    """Base class for Waitables that take mutiple triggers in their constructor"""

    __slots__ = ...
    def __init__(self, *triggers) -> None: ...
    def __repr__(self):  # -> str:
        ...

class Combine(_AggregateWaitable):
    """Fires when all of *triggers* have fired.

    Like most triggers, this simply returns itself.

    This is similar to Verilog's ``join``.
    """

    __slots__ = ...

class First(_AggregateWaitable):
    """Fires when the first trigger in *triggers* fires.

    Returns the result of the trigger that fired.

    This is similar to Verilog's ``join_any``.

    .. note::
        The event loop is single threaded, so while events may be simultaneous
        in simulation time, they can never be simultaneous in real time.
        For this reason, the value of ``t_ret is t1`` in the following example
        is implementation-defined, and will vary by simulator::

            t1 = Timer(10, units="ps")
            t2 = Timer(10, units="ps")
            t_ret = await First(t1, t2)

    .. note::
        In the old-style :ref:`generator-based coroutines <yield-syntax>`, ``t = yield [a, b]`` was another spelling of
        ``t = yield First(a, b)``. This spelling is no longer available when using :keyword:`await`-based
        coroutines.
    """

    __slots__ = ...

class ClockCycles(Waitable):
    """Fires after *num_cycles* transitions of *signal* from ``0`` to ``1``."""
    def __init__(self, signal, num_cycles, rising=...) -> None:
        """Args:
        signal: The signal to monitor.
        num_cycles (int): The number of cycles to count.
        rising (bool, optional): If ``True``, the default, count rising edges.
            Otherwise, count falling edges.
        """
        ...

    def __repr__(self):  # -> str:
        ...

async def with_timeout(
    trigger: Union[Trigger, Waitable, Task, Coroutine[Any, Any, T]],
    timeout_time: Union[float, Decimal],
    timeout_unit: str = ...,
    round_mode: Optional[str] = ...,
) -> T:
    r"""Waits on triggers or coroutines, throws an exception if it waits longer than the given time.

    When a :term:`python:coroutine` is passed,
    the callee coroutine is started,
    the caller blocks until the callee completes,
    and the callee's result is returned to the caller.
    If timeout occurs, the callee is killed
    and :exc:`SimTimeoutError` is raised.

    When an unstarted :class:`~cocotb.coroutine`\ is passed,
    the callee coroutine is started,
    the caller blocks until the callee completes,
    and the callee's result is returned to the caller.
    If timeout occurs, the callee `continues to run`
    and :exc:`SimTimeoutError` is raised.

    When a :term:`task` is passed,
    the caller blocks until the callee completes
    and the callee's result is returned to the caller.
    If timeout occurs, the callee `continues to run`
    and :exc:`SimTimeoutError` is raised.

    If a :class:`~cocotb.triggers.Trigger` or :class:`~cocotb.triggers.Waitable` is passed,
    the caller blocks until the trigger fires,
    and the trigger is returned to the caller.
    If timeout occurs, the trigger is cancelled
    and :exc:`SimTimeoutError` is raised.

    Usage:

    .. code-block:: python

        await with_timeout(coro, 100, "ns")
        await with_timeout(First(coro, event.wait()), 100, "ns")

    Args:
        trigger (:class:`~cocotb.triggers.Trigger`, :class:`~cocotb.triggers.Waitable`, :class:`~cocotb.task.Task`, or :term:`python:coroutine`):
            A single object that could be right of an :keyword:`await` expression in cocotb.
        timeout_time (numbers.Real or decimal.Decimal):
            Simulation time duration before timeout occurs.
        timeout_unit (str, optional):
            Units of timeout_time, accepts any units that :class:`~cocotb.triggers.Timer` does.
        round_mode (str, optional):
            String specifying how to handle time values that sit between time steps
            (one of ``'error'``, ``'round'``, ``'ceil'``, ``'floor'``).

    Returns:
        First trigger that completed if timeout did not occur.

    Raises:
        :exc:`SimTimeoutError`: If timeout occurs.

    .. versionadded:: 1.3

    .. deprecated:: 1.5
        Using ``None`` as the *timeout_unit* argument is deprecated, use ``'step'`` instead.

    .. versionchanged:: 1.7.0
        Support passing :term:`python:coroutine`\ s.
    """
    ...
