"""This type stub file was generated by pyright."""

import typing

from cocotb.binary import BinaryRepresentation, BinaryValue
from cocotb.types.array import Array
from cocotb.types.logic import Logic, LogicConstructibleT
from cocotb.types.range import Range

LogicT = typing.TypeVar("LogicT", bound=Logic)
S = typing.TypeVar("S")
Self = typing.TypeVar("Self", bound="LogicArray")

class LogicArray(Array[Logic]):
    r"""Fixed-sized, arbitrarily-indexed, array of :class:`cocotb.types.Logic`.

    .. currentmodule:: cocotb.types

    :class:`LogicArray`\ s can be constructed from either iterables of values
    constructible into :class:`Logic`: like :class:`bool`, :class:`str`, :class:`int`;
    or from integers.
    If constructed from a positive integer, an unsigned bit representation is used to
    construct the :class:`LogicArray`.
    If constructed from a negative integer, a two's complement bit representation is
    used.
    Like :class:`Array`, if no *range* argument is given, it is deduced from the length
    of the iterable or bit string used to initialize the variable.
    If a *range* argument is given, but no value,
    the array is filled with the default value of Logic().

    .. code-block:: python3

        >>> LogicArray("01XZ")
        LogicArray('01XZ', Range(3, 'downto', 0))

        >>> LogicArray([0, True, "X"])
        LogicArray('01X', Range(2, 'downto', 0))

        >>> LogicArray(0xA)  # picks smallest range that can fit the value
        LogicArray('1010', Range(3, 'downto', 0))

        >>> LogicArray(-4, Range(0, "to", 3))  # will sign-extend
        LogicArray('1100', Range(0, 'to', 3))

        >>> LogicArray(range=Range(0, "to", 3))  # default values
        LogicArray('XXXX', Range(0, 'to', 3))

    :class:`LogicArray`\ s support the same operations as :class:`Array`;
    however, it enforces the condition that all elements must be a :class:`Logic`.

    .. code-block:: python3

        >>> la = LogicArray("1010")
        >>> la[0]                               # is indexable
        Logic('0')

        >>> la[1:]                              # is slice-able
        LogicArray('10', Range(1, 'downto', 0))

        >>> Logic("0") in la                    # is a collection
        True

        >>> list(la)                            # is an iterable
        [Logic('1'), Logic('0'), Logic('1'), Logic('0')]

    When setting an element or slice, the *value* is first constructed into a
    :class:`Logic`.

    .. code-block:: python3

        >>> la = LogicArray("1010")
        >>> la[3] = "Z"
        >>> la[3]
        Logic('Z')

        >>> la[2:] = ['X', True, 0]
        >>> la
        LogicArray('ZX10', Range(3, 'downto', 0))

    :class:`LogicArray`\ s can be converted into :class:`str`\ s or :class:`int`\ s.

    .. code-block:: python3

        >>> la = LogicArray("1010")
        >>> la.binstr
        '1010'

        >>> la.integer          # uses unsigned representation
        10

        >>> la.signed_integer   # uses two's complement representation
        -6

    :class:`LogicArray`\ s also support element-wise logical operations: ``&``, ``|``,
    ``^``, and ``~``.

    .. code-block:: python3

        >>> def big_mux(a: LogicArray, b: LogicArray, sel: Logic) -> LogicArray:
        ...     s = LogicArray([sel] * len(a))
        ...     return (a & ~s) | (b & s)

        >>> la = LogicArray("0110")
        >>> p = LogicArray("1110")
        >>> sel = Logic('1')        # choose second option
        >>> big_mux(la, p, sel)
        LogicArray('1110', Range(3, 'downto', 0))

    Args:
        value: Initial value for the array.
        range: Indexing scheme of the array.

    Raises:
        ValueError: When argument values cannot be used to construct an array.
        TypeError: When invalid argument types are used.
    """

    __slots__ = ...
    @typing.overload
    def __init__(
        self,
        value: typing.Union[
            int, typing.Iterable[LogicConstructibleT], BinaryValue
        ],
        range: typing.Optional[Range],
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        value: typing.Union[
            int, typing.Iterable[LogicConstructibleT], BinaryValue, None
        ],
        range: Range,
    ) -> None: ...
    def __init__(
        self,
        value: typing.Union[
            int, typing.Iterable[LogicConstructibleT], BinaryValue, None
        ] = ...,
        range: typing.Optional[Range] = ...,
    ) -> None: ...
    @property
    def binstr(self) -> str: ...
    @property
    def is_resolvable(self) -> bool: ...
    @property
    def integer(self) -> int: ...
    @property
    def signed_integer(self) -> int: ...
    @typing.overload
    def __setitem__(self, item: int, value: LogicConstructibleT) -> None: ...
    @typing.overload
    def __setitem__(
        self, item: slice, value: typing.Iterable[LogicConstructibleT]
    ) -> None: ...
    def __setitem__(
        self,
        item: typing.Union[int, slice],
        value: typing.Union[
            LogicConstructibleT, typing.Iterable[LogicConstructibleT]
        ],
    ) -> None: ...
    def __repr__(self) -> str: ...
    def __and__(self: Self, other: Self) -> Self: ...
    def __rand__(self: Self, other: Self) -> Self: ...
    def __or__(self: Self, other: Self) -> Self: ...
    def __ror__(self: Self, other: Self) -> Self: ...
    def __xor__(self: Self, other: Self) -> Self: ...
    def __rxor__(self: Self, other: Self) -> Self: ...
    def __invert__(self: Self) -> Self: ...
    def to_BinaryValue(
        self,
        bigEndian: bool = ...,
        binaryRepresentation: BinaryRepresentation = ...,
    ) -> BinaryValue: ...
